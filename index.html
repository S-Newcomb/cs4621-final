<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <!-- The above 3 meta tags *must* come first in the head; any other head content must come *after* these tags -->
    <title>CS 4621: Terrain Generator</title>

    <!-- Bootstrap -->
    <link href="css/bootstrap.min.css" rel="stylesheet">
    <link href="css/cs4620.css" rel="stylesheet">
    <link href="css/jquery-ui.min.css" rel="stylesheet">
    <link href="css/jquery-ui.theme.min.css" rel="stylesheet">
    <link href="css/jquery-ui.structure.min.css" rel="stylesheet">

    <!-- HTML5 shim and Respond.js for IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
    <script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
    <script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
    <![endif]-->
</head>
<body>
<div class="container">
    <h1>CS 4621 Final <span class="subtitle">Terrain Generator</span></h1>
    <div>
        <canvas id="webglCanvas" style="border: none; background-color: black;" width="1200" height="900"></canvas>
    </div>

    <h2>For our final project, we recreated a scene from "Avatar" using procedural world generation. The user
      is free to explore using the arrow keys.
    </h2>

    <h3>Alexander DeGraff (ard96) &middot
        Alisha Mithal (am2658) &middot
        Stephen Newcomb (sn498) &middot
        Jake Sanders (jas222) &middot
        Janie Walters (jjw249)
    </h3>
</div>

<!-- jQuery (necessary for Bootstrap's JavaScript plugins) -->
<script src="js/jquery-3.1.1.min.js"></script>
<script src="js/jquery-ui.min.js"></script>
<script src="js/gl-matrix-min.js"></script>
<script src="js/preloadjs-0.6.2.min.js"></script>

<!-- Shaders -->
<script id="vertexShader" type="x-shader/x-vertex">
  attribute vec3 vert_position;
  attribute vec2 vert_texCoord;

  // transformation matrices
  uniform mat4 modelViewProjection;

  varying vec2 geom_texCoord;

  void main() {
      gl_Position = modelViewProjection * vec4(vert_position, 1.0);

      geom_texCoord = vert_texCoord;
  }
</script>

<script id="fragmentShader" type="x-shader/x-fragment">
  precision highp float;

  uniform sampler2D texture1;

  varying vec2 geom_texCoord;

  void main() {
      gl_FragColor = texture2D(texture1, geom_texCoord);
  }
</script>

<script id ="vertexShaderLand" type="x-shader/x-vertex">
  // items used assign out canvas color and property
  #define epsilon 0.15
  #define PI 3.1415926535897932384626433832795
  #define density 0.2
  #define gradient 1.5
  attribute vec3 vert_position;
  attribute vec2 vert_texCoord;

  uniform mat4 mView;
  uniform mat4 mProj;
  uniform vec2 userPosition;
  uniform vec3 viewDir;
  uniform vec3 sunPosition;
  uniform vec3 sunColor;

  varying vec2 Uvs;
  varying vec3 shader;
  varying vec3 normal;
  varying float visibility;
  varying float zSnow;
  varying vec3 sun;
  varying vec3 color;
  varying vec3 vLighting;

  vec4 mod289(vec4 x) {
    return x - floor(x * (1.0 / 289.0)) * 289.0;
  }

  vec4 permute(vec4 x) {
    return mod289(((x*34.0)+1.0)*x);
  }

  vec4 taylorInvSqrt(vec4 r) {
    return 1.79284291400159 - 0.85373472095314 * r;
  }

  vec2 fade(vec2 t) {
    return t*t*t*(t*(t*6.0-15.0)+10.0);
  }

  // Classic Perlin noise
  float cnoise(vec2 P) {
    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod289(Pi); // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = permute(permute(ix) + iy);

    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);

    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));

    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 2.3 * n_xy;
  }

  // Classic Perlin noise, periodic variant
  float pnoise(vec2 P, vec2 rep) {
    vec4 Pi = floor(P.xyxy) + vec4(0.0, 0.0, 1.0, 1.0);
    vec4 Pf = fract(P.xyxy) - vec4(0.0, 0.0, 1.0, 1.0);
    Pi = mod(Pi, rep.xyxy); // To create noise with explicit period
    Pi = mod289(Pi);        // To avoid truncation effects in permutation
    vec4 ix = Pi.xzxz;
    vec4 iy = Pi.yyww;
    vec4 fx = Pf.xzxz;
    vec4 fy = Pf.yyww;

    vec4 i = permute(permute(ix) + iy);

    vec4 gx = fract(i * (1.0 / 41.0)) * 2.0 - 1.0 ;
    vec4 gy = abs(gx) - 0.5 ;
    vec4 tx = floor(gx + 0.5);
    gx = gx - tx;

    vec2 g00 = vec2(gx.x,gy.x);
    vec2 g10 = vec2(gx.y,gy.y);
    vec2 g01 = vec2(gx.z,gy.z);
    vec2 g11 = vec2(gx.w,gy.w);

    vec4 norm = taylorInvSqrt(vec4(dot(g00, g00), dot(g01, g01), dot(g10, g10), dot(g11, g11)));
    g00 *= norm.x;
    g01 *= norm.y;
    g10 *= norm.z;
    g11 *= norm.w;

    float n00 = dot(g00, vec2(fx.x, fy.x));
    float n10 = dot(g10, vec2(fx.y, fy.y));
    float n01 = dot(g01, vec2(fx.z, fy.z));
    float n11 = dot(g11, vec2(fx.w, fy.w));

    vec2 fade_xy = fade(Pf.xy);
    vec2 n_x = mix(vec2(n00, n01), vec2(n10, n11), fade_xy.x);
    float n_xy = mix(n_x.x, n_x.y, fade_xy.y);
    return 2.3 * n_xy;
  }

  float sinNoise(vec2 temp_pos, float z) {
    float dotval= dot(temp_pos,temp_pos) / 100.;
    return .6*z*sin(dotval) + 0.2*z*sin(temp_pos.x) + 0.2*z*sin(temp_pos.y);
  }
  void main() {
    //applies the rotation transformation to the canvas
    vec2 temp_pos = vert_position.xy+(userPosition);

    float z = cnoise(temp_pos)*.8;
    float z1= sinNoise(temp_pos, z);

    //computing and determining normal
    float zLeft = cnoise(vec2(temp_pos.x - epsilon, temp_pos.y)) * .8;
    float z1Left = sinNoise(vec2(temp_pos.x - epsilon, temp_pos.y), zLeft);
    float zRight = cnoise(vec2(temp_pos.x + epsilon, temp_pos.y)) * .8;
    float z1Right = sinNoise(vec2(temp_pos.x + epsilon, temp_pos.y), zRight);
    float zDown = cnoise(vec2(temp_pos.x, temp_pos.y - epsilon)) * .8;
    float z1Down = sinNoise(vec2(temp_pos.x, temp_pos.y - epsilon), zDown);
    float zUp = cnoise(vec2(temp_pos.x, temp_pos.y + epsilon)) * .8;
    float z1Up = sinNoise(vec2(temp_pos.x, temp_pos.y + epsilon), zUp);

    float dx = (z1Right - z1Left) / (2. * epsilon);
    float dy = (z1Up - z1Down) / (2. * epsilon);

    normal  = normalize(vec3(-dx,-dy,1.));

    //fog
    vec4 userPos = mView * vec4(temp_pos, z1, 1.0);
    float distance = length((gl_Position.xyz - userPos.xyz));
    visibility = exp(-pow((distance*density), gradient));
    visibility = clamp(visibility, 0.0, 1.0);

    //snow TODO make this sin function better
    zSnow = (pnoise(temp_pos, vec2(.05, .05))*.1 + pnoise(temp_pos, vec2(.9, .03)) * .1) + .35;

    gl_Position = mProj * mView * vec4(temp_pos, z1, 1.0);
    shader = vec3(temp_pos,z1);
    Uvs = vert_texCoord;
    sun = sunPosition;
    color = sunColor;
    vec3 ambientLight = vec3(0.4, 0.4, 0.4);
    vec3 directionalVector = normalize(sunPosition - shader);

    float directional = max(dot(normal.xyz, directionalVector), 0.0);
    vLighting = ambientLight + (sunColor * directional);
  }

</script>

<script id = "fragmentShaderLand" type = "x-shader/x-fragment">
  #define PI 3.1415926535897932384626433832795
  precision highp float;

  uniform sampler2D texture0;
  uniform sampler2D texture1;
  uniform sampler2D texture2;
  uniform sampler2D  texture3;

  varying vec3 shader;
  varying float visibility;
  varying vec3 normal;
  varying float zSnow;
  varying vec3 sun;
  varying vec3 color;
  varying vec3 vLighting;

  void main() {
    vec3 skyColor = vec3(0., 0., 0.);
    vec4 color0 = texture2D(texture0,shader.xy);
    vec4 color1 = texture2D(texture1,shader.xy);
    vec4 color2 = texture2D(texture2,shader.xy);
    vec4 color3 = texture2D(texture3,shader.xy);
    float w0 = .1; //soil
    float w1 = 0.;
    float w2 = 0.;
    float w3 = 0.;
    vec3 upVector = vec3(0, 0, 1);

    float cosAngle = dot(upVector, normal);
    if (cosAngle > .9){
      w2 =.9; //angle is low, flat terrain, grass
    }
    else if (cosAngle > .6){
      w3 = .9 - ((cosAngle - .6) * .9 / .3); //angle is steeper, more rocky terrain
      w2 = (cosAngle - .6) * .9 / .3;
    }
    else {
      w3 = .9;
    }

    if (shader.z - zSnow > .2) {
      w1 = .8;
      w0 = 0.;
    }
    else if (shader.z - zSnow > 0.) {
      w1 = (shader.z - zSnow) * 5.;
      w2 -= w1 / 2.;
    }
    vec4 weight =  color0*w0+ color1*w1+color2*w2+ color3*w3;
    vec4 terrain = mix(vec4(skyColor, 1.0), weight, visibility);
    gl_FragColor = vec4(terrain.rgb * vLighting, terrain.a);
  }

</script>

<script id="vertexShaderSkyBox" type="x-shader/x-vertex">
    attribute vec3 vert_position;

    // TODO: Add P, V, M matrices
    uniform mat4 xform_projMat;
    uniform mat4 xform_viewMat;
    uniform mat4 xform_modelMat;

    varying vec3 texCoords;

    void main() {
        // TODO: Multiply by P*V*M
        texCoords = vert_position;
        gl_Position = xform_projMat * xform_viewMat * xform_modelMat * vec4(vert_position, 1.0);
    }
</script>

<script id="fragmentShaderSkyBox" type="x-shader/x-fragment">
    precision highp float;

    varying vec3 texCoords;

    uniform samplerCube skyBox;

    void main() {
        gl_FragColor = textureCube(skyBox, texCoords);
    }
</script>

<!-- Our own scripts -->
<script src="src/Scene/material.js"></script>
<script src="src/Scene/geometry.js"></script>
<script src="src/Scene/transform.js"></script>
<script src="src/Scene/scene-object.js"></script>
<script src="src/Scene/camera.js"></script>
<script src="src/Scene/mesh-object.js"></script>
<script src="src/Scene/scene.js"></script>
<!-- <script src="src/gl/render.js"></script> -->
<!-- <script src="src/MarchingCubes/MarchTables.js"></script> -->
<script src="src/MarchingCubes/MarchingCubes.js"></script>
<script src="src/core.js"></script>
<script src="src/perlin.js"></script>
<!-- <script src="src/maze-core.js"></script> -->
<!-- <script src="src/test-core.js"></script> -->

</body>
</html>
